////////////////////////////////////////////////////////////////////////
// Class:       LaserRawDigitGenTest
// Module Type: analyzer
// File:        LaserRawDigitGenTest_module.cc
//
// Generated at Thu Sep 22 23:55:54 2016 by matthias,,, using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/RawData/RawDigit.h"
#include "lardata/RawData/raw.h"

#include "larcore/Geometry/Geometry.h"

class LaserRawDigitGenTest;

class LaserRawDigitGenTest : public art::EDAnalyzer {
public:
    explicit LaserRawDigitGenTest(fhicl::ParameterSet const &p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    LaserRawDigitGenTest(LaserRawDigitGenTest const &) = delete;

    LaserRawDigitGenTest(LaserRawDigitGenTest &&) = delete;

    LaserRawDigitGenTest &operator=(LaserRawDigitGenTest const &) = delete;

    LaserRawDigitGenTest &operator=(LaserRawDigitGenTest &&) = delete;

    // Required functions.
    void analyze(art::Event const &e) override;

    void reconfigure(fhicl::ParameterSet const &p) override;


private:
    std::string fRawDigitLabel;
    std::string fRawDigitModul;
    std::string fTestConfigFile;

    geo::GeometryCore const *fGeometry;       ///< pointer to Geometry provider

};


LaserRawDigitGenTest::LaserRawDigitGenTest(fhicl::ParameterSet const &pset) : EDAnalyzer(pset)  // ,
// More initializers here.
{
    fGeometry = &*(art::ServiceHandle<geo::Geometry>());
    this->reconfigure(pset);
}

void LaserRawDigitGenTest::analyze(art::Event const &event) {
    auto id = event.id().event();
    auto DigitTag = art::InputTag(fRawDigitModul, fRawDigitLabel);

    art::ValidHandle<std::vector<raw::RawDigit> > RawDigits = event.getValidHandle<std::vector<raw::RawDigit>>(DigitTag);


    if (fTestConfigFile.compare("RawDigits_Test_SingleGeneration.txt") == 0)
    {
        std::cout << "==> Testing Single Raw Digit Generation" << std::endl;

        for (auto const &RawDigit : *RawDigits) {

            auto wire_id = fGeometry->ChannelToWire(RawDigit.Channel()).front();
            auto max = std::max_element(RawDigit.ADCs().begin(), RawDigit.ADCs().end());
            auto max_idx = std::distance(RawDigit.ADCs().begin(), max);

            assert(wire_id.Wire == 20);
            assert(wire_id.Plane == 2);
            assert(RawDigit.ADCs().size() == 20);
            assert(max_idx == 10);
            assert(RawDigit.ADCs().at(max_idx) == 5);

            for (auto ADC : RawDigit.ADCs()) {
                std::cout << ADC << " ";
            }
        }
    }
    else if ((fTestConfigFile.compare("RawDigits_Test_MultiGeneration.txt") == 0)){
        for (auto const &RawDigit : *RawDigits) {
            std::cout << "==> Testing Multiple Digit Generation" << std::endl;

            auto max = std::max_element(RawDigit.ADCs().begin(), RawDigit.ADCs().end());
            auto max_idx = std::distance(RawDigit.ADCs().begin(), max);

            assert(max_idx == 10 + id);
            assert(10 * RawDigit.ADCs().at(max_idx) + 10);
        }
    }
    else if (fTestConfigFile.compare("RawDigits_Test_MultiplicityGeneration.txt") == 0){
        for (auto const &RawDigit : *RawDigits) {
            std::cout << "==> Testing Multiplicity Digit Generation" << std::endl;

            auto max = std::max_element(RawDigit.ADCs().begin(), RawDigit.ADCs().end());
            auto max_idx = std::distance(RawDigit.ADCs().begin(), max);

            auto min = std::min_element(RawDigit.ADCs().begin(), RawDigit.ADCs().end());
            auto min_idx = std::distance(RawDigit.ADCs().begin(), min);


            assert(max_idx == 5);
            assert(min_idx == 15);
            assert(RawDigit.ADCs().at(max_idx) == 25);
            assert(RawDigit.ADCs().at(min_idx) == 10);

        }
    }

}

void LaserRawDigitGenTest::reconfigure(fhicl::ParameterSet const &pset) {
    fRawDigitModul = pset.get<std::string>("RawDigitModul");
    fRawDigitLabel = pset.get<std::string>("RawDigitLabel");

    fTestConfigFile = pset.get<std::string>("TestConfigFile");
    // Implementation of optional member function here.
}

DEFINE_ART_MODULE(LaserRawDigitGenTest)
