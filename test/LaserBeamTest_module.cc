////////////////////////////////////////////////////////////////////////
// Class:       LaserBeamTest
// Module Type: analyzer
// File:        LaserBeamTest_module.cc
//
// Generated at Fri Oct 28 13:49:04 2016 by matthias,,, using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "LaserObjects/LaserHits.h"
#include "LaserObjects/LaserBeam.h"

#include "LaserObjects/LaserUtils.h"
#include "TMath.h"
class LaserBeamTest;

class LaserBeamTest : public art::EDAnalyzer {
public:
    explicit LaserBeamTest(fhicl::ParameterSet const &p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    LaserBeamTest(LaserBeamTest const &) = delete;

    LaserBeamTest(LaserBeamTest &&) = delete;

    LaserBeamTest &operator=(LaserBeamTest const &) = delete;

    LaserBeamTest &operator=(LaserBeamTest &&) = delete;

    // Required functions.
    void analyze(art::Event const &e) override;

    void reconfigure(fhicl::ParameterSet const &pset) override;

    void beginJob() override;

private:

};


LaserBeamTest::LaserBeamTest(fhicl::ParameterSet const &pset)
        :
        EDAnalyzer(pset)  // ,
{
    this->reconfigure(pset);
}

void LaserBeamTest::analyze(art::Event const &event) {

    detinfo::DetectorProperties const *DetProperties = lar::providerFrom<detinfo::DetectorPropertiesService>();
    geo::GeometryCore const* Geometry = &*(art::ServiceHandle<geo::Geometry>());

    TVector3 Position(120., 0., -10.);
    TVector3 Direction(0., 0., 1.);

    lasercal::LaserBeam LaserBeam(Position, Direction);

    LaserBeam.Print();

    std::cout << "==> Testing Laser Beam" << std::endl;
    std::cout << "tick entry / exit " << LaserBeam.getEntryTick() << " / " << LaserBeam.getExitTick() << std::endl;
    std::cout << "(U) entry / exit wire: " << LaserBeam.getEntryWire().at(0) << " / " << LaserBeam.getExitWire().at(0) << std::endl;
    std::cout << "(V) entry / exit wire: " << LaserBeam.getEntryWire().at(1) << " / " << LaserBeam.getExitWire().at(1) << std::endl;
    std::cout << "(Y) entry / exit wire: " << LaserBeam.getEntryWire().at(2) << " / " << LaserBeam.getExitWire().at(2) << std::endl;

    auto sample_rate = DetProperties->SamplingRate() / 1000;        // in us
    auto tick_offset = DetProperties->TriggerOffset();              // in ticks
    auto drift_speed = DetProperties->DriftVelocity();              // in cm/us

    auto expected_entry_tick = (int) ((Position.X()) / drift_speed  / sample_rate) + tick_offset;
    assert(LaserBeam.getEntryTick() == expected_entry_tick);
    assert(LaserBeam.getExitTick() == expected_entry_tick);

    // entry positions
    assert(LaserBeam.getEntryWire().at(0).Wire == 338);
    assert(LaserBeam.getEntryWire().at(1).Wire == 333);
    assert(LaserBeam.getEntryWire().at(2).Wire == 0);

    // exit positions
    assert(LaserBeam.getExitWire().at(0).Wire == 2066);
    assert(LaserBeam.getExitWire().at(1).Wire == 2061);
    assert(LaserBeam.getExitWire().at(2).Wire == 3455);




}

void LaserBeamTest::reconfigure(fhicl::ParameterSet const &pset) {
}

void LaserBeamTest::beginJob() {
}


DEFINE_ART_MODULE(LaserBeamTest)
