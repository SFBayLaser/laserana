////////////////////////////////////////////////////////////////////////
// Class:       LaserRawDigitGenerator
// Module Type: producer
// File:        LaserRawDigitGenerator_module.cc
//
// Generated at Thu Sep 22 16:12:52 2016 by matthias,,, using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Utilities/Exception.h"

#include "lardata/RawData/RawDigit.h"
#include "lardata/RawData/raw.h"

#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include <fstream>
#include <boost/tokenizer.hpp>
#include <boost/math/distributions/normal.hpp>
    using boost::math::normal;

#include <boost/random/mersenne_twister.hpp>
#include <boost/random/uniform_int_distribution.hpp>

class LaserRawDigitGenerator;

/* This module produces Gaussian hits which can be specified in the RawDigit file. It fills the rest of
 * the wire with random values.
*/

class LaserRawDigitGenerator : public art::EDProducer {
public:
    explicit LaserRawDigitGenerator(fhicl::ParameterSet const &p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    LaserRawDigitGenerator(LaserRawDigitGenerator const &) = delete;

    LaserRawDigitGenerator(LaserRawDigitGenerator &&) = delete;

    LaserRawDigitGenerator &operator=(LaserRawDigitGenerator const &) = delete;

    LaserRawDigitGenerator &operator=(LaserRawDigitGenerator &&) = delete;

    // Required functions.
    void produce(art::Event &e) override;

    // Selected optional functions.
    void beginJob() override;

    void beginRun(art::Run &r) override;

    void endJob() override;

    void endRun(art::Run &r) override;

    void reconfigure(fhicl::ParameterSet const &p) override;

    std::string PrintConfig(std::vector<float> Config);
private:

    // Declare member data here.

    detinfo::DetectorProperties const *fDetProperties;  ///< pointer to detector properties provider
    geo::GeometryCore const *fGeometry;       ///< pointer to Geometry provider

    // External Hit generator definitions
    std::string fRawDigitFile;
    std::string fRawDigitLabel;
    uint fNoiseAmplitude;
    int fNumberTimeSamples;

    unsigned int NumberTimeSamples;
    // inner most vector is configuration for hit
    // middle vector contains all hits for the specific event
    // outer vector contians hits over all events
    std::vector<std::vector<std::vector<float> > > RawDigitValues; ///< line by line csv container

    enum RawDigitDataStructure {
        Plane,
        Wire,
        CenterTick,
        Width,
        Amplitude,
        Offset,
        Multiplicity
    };

    bool DEBUG = true;

};


LaserRawDigitGenerator::LaserRawDigitGenerator(fhicl::ParameterSet const &pset)
// :
// Initialize member data here.
{
    fGeometry = &*(art::ServiceHandle<geo::Geometry>());
    fDetProperties = lar::providerFrom<detinfo::DetectorPropertiesService>();
    // Call appropriate produces<>() functions here.
    this->reconfigure(pset);

    produces<std::vector<raw::RawDigit> >(fRawDigitLabel);

}

// ==================================== PRODUCE ======================================
void LaserRawDigitGenerator::produce(art::Event &event) {
    auto id = event.id().event();
    std::unique_ptr<std::vector<raw::RawDigit> > RawWires(new std::vector<raw::RawDigit>);

    // Handle config vs events
    if (id > RawDigitValues.size() - 1) {
        event.put(std::move(RawWires), fRawDigitLabel);
        return;
    };

    boost::random::mt19937 gen;
    auto RawDigitsInThisEvent = RawDigitValues.at(id);
    //std::vector<raw::RawDigit> RawWires;

    // create all hits in this event
    for (auto SingleHit : RawDigitsInThisEvent) {
        if (DEBUG) std::cout << PrintConfig(SingleHit) << std::endl;

        raw::RawDigit::ADCvector_t WireADCSignal(NumberTimeSamples, 0);

        // Construct the appropriate channel for this hit
        uint plane = (uint) SingleHit.at(RawDigitDataStructure::Plane);
        uint wire = (uint) SingleHit.at(RawDigitDataStructure::Wire);

        auto channel = fGeometry->PlaneWireToChannel(plane, wire);

        uint multiplicity = (uint) SingleHit.at(RawDigitDataStructure::Multiplicity);
        if (multiplicity == 1) {
            // Fill the vector with some random values
            boost::random::uniform_int_distribution<> Noise(-fNoiseAmplitude, fNoiseAmplitude);
            for (auto& Digit : WireADCSignal) {
                Digit += Noise(gen) + SingleHit.at(RawDigitDataStructure::Offset);
            }
        }
        else {
            // just copy the previous generated signal into the current vector
            // and forget about the one we already stored.
            if (RawWires->empty() || RawWires->back().Channel() != channel){
                throw art::Exception(art::errors::LogicError)
                        << "Multiplicity error @ " << id << "\n"
                        << "previous raw wire was either empty or not identical to current wire"
                        <<  PrintConfig(SingleHit)
                        << std::endl;
            }
            WireADCSignal = RawWires->back().ADCs();
            RawWires->pop_back();
        }

        uint mean = (uint) SingleHit.at(RawDigitDataStructure::CenterTick);
        uint width = (uint) SingleHit.at(RawDigitDataStructure::Width);
        int amplitude = SingleHit.at(RawDigitDataStructure::Amplitude);

        int range = 3 * width; // min and max z = -range to +range.
        int start_range = mean - range;
        uint end_range = mean + range;
        // Handle boundary conditions
        if (start_range < 0) start_range = 0;
        if (end_range > NumberTimeSamples) end_range = NumberTimeSamples;

        normal HitFunction( (double) mean, width ); // (default mean = zero, and standard deviation = unity)

        // Generate the hit and place them in the right spot
        for (int TimeTick = (uint) start_range ; TimeTick < (int) end_range; ++TimeTick)
        {
            WireADCSignal.at(TimeTick) += amplitude * 2.5066282746310002 * width * pdf(HitFunction, TimeTick);
        }

        //if (DEBUG) {
        //    for (auto Digit : WireADCSignal) std::cout << Digit << " ";
        //}

        auto RawDigit = raw::RawDigit(channel, WireADCSignal.size(), WireADCSignal);
        RawWires->emplace_back(std::move(RawDigit));
        WireADCSignal.clear();
    }
    if (DEBUG) {
        for (auto Wire : *RawWires) {
            std::cout << "channel: " << Wire.Channel() << std::endl;
            for (auto ADC : Wire.ADCs()) {
                std::cout << ADC << " ";
            }
        }
    }

    event.put(std::move(RawWires), fRawDigitLabel);

}
// ==================================== PRODUCE ======================================

void LaserRawDigitGenerator::beginJob() {
    // Reading of RawDigit config file
    int EventIdx = -2;

    // read the hit data file into a vector
    std::string FileName = fRawDigitFile;
    fstream stream(FileName, std::ios::in);
    if (stream) {
        typedef boost::tokenizer<boost::char_separator<char> > Tokenizer;
        boost::char_separator<char> sep(", ");
        std::string line;

        std::vector<std::vector<float>> Hits;

        while (getline(stream, line)) {
            // skip comments
            if (line[0] == '#') {
                if (EventIdx > -1) RawDigitValues.push_back(Hits);
                Hits.clear();
                EventIdx++;
                continue;
            }

            Tokenizer info(line, sep); // tokenize the line of data
            std::vector<float> values;
            for (Tokenizer::iterator it = info.begin(); it != info.end(); ++it) {
                // convert data into double value, and store
                values.push_back(std::strtof(it->c_str(), 0));
            }
            // store array of values
            Hits.push_back(values);


            if (DEBUG) {
                std::cout << "DEBUG " << EventIdx << " ";
                for (auto entry : values) {
                    std::cout << entry << " ";

                }
                std::cout << std::endl;
            }
        }
        stream.close();
    } else {
        stream.close();
        throw art::Exception(art::errors::FileOpenError) << " File does not exist: " << FileName << std::endl;
    }

    // Config TPC properties
    if (fNumberTimeSamples == -1) NumberTimeSamples = fDetProperties->NumberTimeSamples();
    else NumberTimeSamples = (uint) fNumberTimeSamples;// fDetProperties->NumberTimeSamples();
}

void LaserRawDigitGenerator::beginRun(art::Run &r) {
    // Implementation of optional member function here.
}

void LaserRawDigitGenerator::endJob() {
    // Implementation of optional member function here.
}

void LaserRawDigitGenerator::endRun(art::Run &r) {
    // Implementation of optional member function here.
}

void LaserRawDigitGenerator::reconfigure(fhicl::ParameterSet const &pset) {
    // Implementation of optional member function here.
    fRawDigitFile = pset.get<std::string>("RawDigitFile");
    fNoiseAmplitude = pset.get<uint>("NoiseAmplitude");
    fNumberTimeSamples = pset.get<int>("NumberTimeSamples", -1);

    // Tag for producing raw digit data
    fRawDigitLabel = pset.get<std::string>("RawDigitLabel", "GeneratedRaw");
}

std::string LaserRawDigitGenerator::PrintConfig(std::vector<float> Config) {
    std::stringstream ss;
    ss << "\n"
       << "Plane:        " << Config.at(RawDigitDataStructure::Plane) << "\n"
       << "Wire:         " << Config.at(RawDigitDataStructure::Wire) << "\n"
       << "CenterTick:   " << Config.at(RawDigitDataStructure::CenterTick) << "\n"
       << "Width:        " << Config.at(RawDigitDataStructure::Width) << "\n"
       << "Amplitude:    " << Config.at(RawDigitDataStructure::Amplitude) << "\n"
       << "Offset:       " << Config.at(RawDigitDataStructure::Offset) << "\n"
       << "Multiplicity: " << Config.at(RawDigitDataStructure::Multiplicity) << "\n";

    return ss.str();
}

DEFINE_ART_MODULE(LaserRawDigitGenerator)
